✅ 제너레이터와 비동기

* ** 제너레이터는 `흐름 제어(중단 가능)`가 가능하므로, 아래와 같이 비동기를 동기적으로 표현 가능하다.
  * apiCall은 `예를 들어` 아래와 같다.
    ```js
    const iter = gen();
    iter.next();

    function apiCall() {
      $.ajax({
        url: 'http://test.com',
        // ...
        success: (data) => {
          iter.next(data);  // A
        },
        fail: (err) => {
          iter.throw(err);  // B
        }
      });
    }
    ```
  * `일반 함수`
    * 실제로 apiCall은 undefined를 반환하고
    * 어떤 값을 반환하더라도 끝나는 시점을 잡을 수가 없다.
      ```js
      function gen() {
        const res = apiCall();
        console.log(res); // undefined
      }
      ```
  * ** `제너레이터`
    * ** `yield`로 apiCall의 `작업이 끝날때까지 기다릴 수 있고`,
    * ** `yield`로 apiCall의 `A(iter.next(data))`로 `응답 결과를 받을 수 있다.`
      ```js
      function* gen() { // ** [이 내부에서는] 동기적으로 표현이 가능하다!!!
        const res = yield apiCall();
        console.log(res); // 어떤 형태의 data
      }
      ```
    * ** ** 결과적으로 `제너레이터 함수 [** 안에서는]` 비동기적인 작업을 `동기적으로 표현이 가능하다`!!!
      * `제너레이터` 안 ~= `async 함수` 안