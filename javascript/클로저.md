✅ 클로저

* 선언되었을 당시의 `환경(정보)을 기억`하는 함수, 현상
* ** 함수 `자신이 포함하는 스코프`들의 `변수`들을 추적하는 함수
  ```js
  const initCloser = (a) => {
    const b = 'b';
    /** 클로저 함수 */
    return (c) => {
      return a + b + c;
    }
  }
  const closer = initCloser('a');
  closer('c'); // abc
  ```

<hr />

* 비동기 처리, 이벤트 루프와 관련해서 아래 내용을 보자
  * 아래 경우, 태스크 큐에서 setTimeOut의 ** `콜백이 실행되는 시점에` 변수 i를 추적하기 때문에(`렉시컬 스코핑`) 10이 10번 출력된다.
    ```js
    let i;
    for (i = 0; i < 10; i++) {
      setTimeout(() => {
        console.log(i);
      }, 0);
    } // 10이 10번 출력
    ```
  * 하지만 아래와 같이 setTimeOut을 즉시실행함수로 감싸고, 이 즉시실행함수가 클로저로써 동작을 해 원하는 결과를 얻을 수 있다.
    ```js
    let i = 0;
    for (i = 0; i < 10; i++) {
      (function (num) {
        setTimeout(() => {
            console.log(num);
          }, 0);
      })(i);
    }
    ```
  * (참고) `let`은 반복문 블록 스코프에서 `항상 새로 선언, 할당`되기 때문에 위와 같은 문제를 간단히 해결할 수 있다.
    ```js
    for (let i = 0; i < 10; i++) {
      // let i = 0, 1, 2, 3 .... --> 매 순회시 새로 선언, 할당된다.
      setTimeout(() => {
        console.log(i);
      }, 0);
    }

    // 0
    // 1
    // ..
    // ..
    // 9
    ```