✅ 제너레이터
* 자바스크립트에서 `함수는 한번 실행되면 중단할 수가 없다.`
* 따라서 이미 실행되고 있는 코드에 끼어들 수가 없다.
* (`멀티 스레드`, `선점형 언어`도 아니므로)
  ```javascript
  let a = 0;

  function foo() {
    a++;
    
    /********************/
    // 실행 도중에 이부분에 끼어들어서 다른 결과를 내고 싶은데, 방법이 없다.
    /********************/

    console.log(a);
  }

  foo(); // 1
  ```
* 제너레이터를 사용하면,
  ```javascript
  let a = 0;

  function* foo() {
    a++;
    yield;
    console.log(a);
  }

  const iter = foo();

  iter.next();
  a++;
  iter.next(); // 2
  iter.return();
  ```

<hr />

* 위 내용을 할수있도록 도입한 함수가 `ES6`의 `제너레이터`이다.
* ** `비동기 흐름`제어에 유용하다.

<hr />

* 각 반복자 호출시 특정한 객체를 리턴하는데, 해당 객체는 `value`, `done`으로 구성되어 있다.
  * value: `return` 또는 `yield`된 값
  * done: `반복할 요소가 더 남았는지` 여부
    ```javascript
    function* foo() {
      yield 1;
      return 2;
    }

    const iter = foo();

    console.log(iter.next()); // { value: 1, done: false }
    console.log(iter.next()); // { value: 2, done: true }
    iter.return();
    ```
* `yield` 문법이 헷갈리기 쉬운데, 주의해야 한다.
  ```javascript
  let a;
  
  function* foo() {
    a = (yield 100); // 여기서 100은 a에 영향을 주지 못한다.

    // yield 단어가 위치한 곳에서는 iter로부터 message를 받는 곳이고, 
    // 그 message를 '선언부'에 반영한다. 
    
    // 100은 다음 next시 반환할 값이다. a에 영향을 주지 않는다.
  }

  const iter = foo();
  iter.next();
  iter.next(5);

  console.log(a); // 5
  ```
* ** `선언부`와 `호출부`가 입력/출력 `메세지를 주고받는 것`도 가능하다.
  ```javascript
  function* foo() {
    let a 
      = (yield) * 100; // 2. 2가 전달된다.
    return a;
  }

  const iter = foo();
  iter.next();
  const res = iter.next(2); // 1. 2를 메세지로 보낸다.

  console.log(res.value); // 200 
  ```