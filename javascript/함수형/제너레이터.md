✅ 제너레이터
* Iterator protocol을 구현한 <b>이터러블 객체를 쉽게 구현하기 위한 함수 표현법</b>
* 비동기 처리를 <b>동기식으로</b> 처리하기 위함. 아래를 보자.
```javascript
const asyncGetId = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(Math.floor(Math.random() * 4 + 1));
        }, 0);
    });
}

const asyncGetNameById = (id) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            const list = ['Lee', 'Kim', 'Park', 'Choi', 'Hwang'];
            resolve(list[id]);
        }, 0);
    });
}
```
* 아래와 같이 해결할 경우, 동기식 함수의 근본적인 문제를 해결할 수 없다.
```javascript
asyncGetId()
    .then(id => {
        asyncGetNameById(id)
            .then((name) => {
                console.log(name);
            });
    });
```
* 아래와 같이 해결할 경우 조금 더 명확해졌지만, <b>일반적인 다른 동기식 코드와 작성법, 흐름, 에러처리 모두 다르다.</b>
* 그리고, then에 연결할 함수가 또 필요한데 그 함수의 파라미터, 반환값이 

???????????????????????????????????? 작성중 http://jeonghwan-kim.github.io/2016/12/15/coroutine.html 참고






```javascript
asyncGetId()
    .then(id => asyncGetNameById(id))
    .then(name => console.log(name));

/** 조금 더 발전해서 */
asyncGetId()
    .then(asyncGetNameById)
    .then(console.log);
```
* <b>협력형 멀티태스킹 방식</b>(동시성)이 가능함
?????????????????????????? 동시적이라는 것을 이해 잘 못하겠음




* let ... of문으로 순회 시 value가 자동으로 요소로 선택된다. (<b>next 객체가 아니라</b>)
```javascript
const gen = function* () {
    for (let i = 0; i < 5; i++) { yield i; }
}

const iter = gen();
const results = [];

for (let i of iter) { results.push(i); }

console.log(results); // [ 0, 1, 2, 3, 4 ]
```
* <b>지연 평가(lazy evaluation)</b>가 가능하다.
* <b>코루틴</b>: 여러개의 함수를 반환값 없이 중단 및 실행 시킬수 있는 제어구조
* await / async는 내부적으로 제너레이터를 사용해서 구현되어 있다.