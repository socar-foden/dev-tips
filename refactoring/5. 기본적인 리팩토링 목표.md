# 5. 기본적인 리팩토링 목표

#### # 리팩토링

* `품질을 향상`시키려고 `코드 동작을 변화하지 않고` 안전하게 코드를 변경하는 것

#### # 기본 기능의 구성요소 6가지

* 대규모(bulk) - (코드 분기, 코드 줄)
* 입력
* 출력
* 부가 작용
* this: 암시적 입력
* 비공개

## 5.1 대규모 함수

#### # 대규모 함수를 옹호하는 입장

* 너무 작은 수준의 함수를 비판하기도 한다. 하지만, `테스트 관점에서는` 여러개의 작은 함수들을 테스트 하는 것이 훨씬 쉽다.

## 5.2 입력

#### # 입력(매개변수)의 종류

1. `명시적` - 실제 호출에서 받게되는 매개변수
2. `암시적` - this
3. `비지역적` - 외부의 변수

* 위 3가지 중 `1, 2, 3` 순서로 비중을 둬야 한다.
* (특히, `3. 비지역적 입력은 없는 것이 좋다.`)

#### # options 매개변수

* 추가 매개변수는 호출 시, 코드를 줄일 수 있지만, 함수 내부가 복잡해진다.
  ```javascript
  function func(number, options) {
    if (options.a) {
      // ..
    }
    if (options.b) {
      // ..
    }
    // ..
  }
  ```
* `실제 필요한 단위`로, `실제 갖고 있는 내용`을 기준으로 받고, 이름을 정하는 것이 좋다.
* 아래 ES2015 문법을 사용는 것을 권장한다.
  ```javascript
  function print({str: str, count: count}) {
    // ...
  }

  // 아래는 축약
  function print({str, cpimt}) {
    // ...
  }
  ```

#### # 정리

  * `입력 자체의 수`가 `적을수록` 좋다.
  * `비지역적` 입력이 `적을수록` 좋다.
  * this, 비지역적 `<<<<<<< 명시적`

## 5.3 출력

#### # 권장되는 접근법

* `일관되고 단순한 값`을 반환
* `null, undefined` 등 정의되지 않은 값을 반환하는 것을 `피한다.`
  * 차라리 `영향을 받은 객체` or `this`를 반환해주는 것이 낫다. (`디버깅, 테스트`에 도움이라도 되는 어떠한 것이라도)
* `다른 타입의 값을 섞어서 반환하지 않는다.`
  ```javascript
  function func() {
    if (true) {
      return true;
    }
    return 'hello!';
  }
  ```

## 5.4 부가 작용

#### # 다른 언어와의 차이점

* DOM을 제어해야 하기 때문에 부가작용은 `필연적으로 일어난다.`

#### # 부가 작용의 문제점

* 테스트를 어렵게 한다.
* 디자인이 복잡해진다.

## 5.5 상황 1: 암시적 입력(this)

### 5.5.1 Strict 모드에서 this

#### # this 변경(명시적)

* `call`
* `apply`
* `bind`: this가 바인딩 된 새로운 함수를 `반환`

#### # this를 반환함으로써 얻는 이점

1. `테스트`가 쉬워진다.
2. `유연한 인터페이스`를 가지게 된다. (`체이닝`)
    ```javascript
    const obj = {
      number: 0;
      setNumber: function (number) {
        this.number = number;
        return this; // setter임에도 this를 반환한다.
      }
    };

    // 테스트 과정에서, 반환된 this를 사용해 변경여부를 확인할 수 있다.
    ```