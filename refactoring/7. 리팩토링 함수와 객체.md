# 7. 리팩토링 함수와 객체

## 7.1 개선된 코드

## 7.2 배열과 객체 대안

### 7.2.1 배열 대안: Set

#### # 배열과의 차이점

* 특정 값을 `하나만` 보유할 수 있다.
  * (`중복체크` 로직을 없앨 수 있다.)

### 7.2.2 배열 대안: 객체

#### # 배열 대신 객체를 쓰기 좋은 상황

1. `순서에 신경쓰지 않을 때`
2. `여러 유형을 혼합`해서 사용하고 싶을 때
3. 인덱스보다 `의미있는 레이블`을 원할 때

#### # 배열과 객체의 구별

* 배열과 객체는 완전히 구별할 수 없다.

### 7.2.2 객체 대안: Map

#### 객체 대신 Map을 사용하는 이유

> 객체, Map과 같은 것들을 `컨테이너`라고 한다.

1. 컨테이너의 `크기를 쉽게 알고 싶을 때`
2. 객체와 함께 올 수 있는 `계층적 개체들은 원하지 않을 때`
3. `서로 비슷한 요소`에 대한 컨테이너가 필요할 때
4. 일반적으로 `컨테이너를 반복`하고 싶을 때

#### # Set, Map의 약한(weak) 버전

* `WeakSet`, `WeakMap`
  * `키`를 약하게 유지한다.
    * (키가 어디에서도 `참조되지 않을 때`, `가비지 컬렉션`에 의해 제거된다.)
  * `반복될 수 없다.`
  * `크기`에 대한 참조가 없다.
  * 키, 값 모두 `Object만` 가능하다.
    * `(원시형 불가)`

### 7.2.4 배열 대안: 비트 필드

## 7.3 가진 것 테스트

### 7.3.1 설정 테스트

### 7.3.2 classify를 위한 특성화 테스트

#### # 기존 코드에 관한 테스트(특성화 테스트)

```javascript
function classify(chords){
  var classified = {};
  // ...
  console.log(classified); // 반환하지 않는다.
};
```

* `테스트 코드가 존재하지 않았던` classify 함수에 대한 테스트 코드를 작성한다.
* 해당 함수는 console.log를 실행하고, 아무것도 반환하지 않았지만, `테스트를 위해 원하는 값`(classified)을 반환하기를 바라는 테스트 코드를 작성한다.

### 7.3.3 welcomeMessage 