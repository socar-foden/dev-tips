# 8. 계층 구조 내부의 리팩토링

## 8.1 CRUD 애플리케이션과 프레임워크

#### # CRUD 애플리케이션의 구성

* 다음 2가지 `고수준 작업`으로 이루어져있다.
  * 데이터 `구성`
  * 데이터 `표현`

#### # 프레임워크의 단점

1. 프레임워크 안에서 표준화된 인터페이스를 따르기 위한 `팀원들의 노력`
2. 프레임워크에서의 `'리팩토링'`은 `코드 재작성`을 의미한다.
3. 언어 자체보다는 프레임워크에 대한 의존을 하기 쉽다.

## 8.2 계층 구조 구축하기

#### # 계층 구조를 구축해야 하는 이유

1. 부모 객체(+ 클래스)를 사용해, 코드의 `재사용과 반복을 줄인다.`
2. `if 분기`를 줄일 수 있다.
    ```javascript
    class Word{
      // ...
      lookUp(){
        if (this.language === "Japanese") { // 하나의 상위클래스에서 모두 위임 -> if문 증가
          return `http://jisho.org/search/${this.word}`;
        } else {
          return `https://en.wiktionary.org/wiki/${this.word}`;
        }
      };
      // ...
    };
    ```

#### # 깊은 계층 구조

* `하위 클래스가 자체적으로` 일을 처리하도록 하는 것은 `코드를 깔끔하게` 만든다.
* ** 하지만 `너무 깊은 계층 구조`를 가지게 된다면, `코드를 혼란스럽게` 만들수도 있다.

## 8.3 계층 구조 파헤치기

### 8.3.1 생성자 함수

#### # [[Prototype]] 링크 vs .prototype

* ** 생성자 함수를 사용할 시, `[[Prototype]] 링크`와 `.prototype`의 구별이 중요하다.
  ```javascript
  const Animal = function (type) {
    this.type = type;
  }

  const Cat = function (type, detail) {
    Animal.call(this, type);
    this.detail = detail;
  }

  // 'Animal.prototype을 [[Prototype]] 링크로 참조하는 객체'를
  // ----> Cat.prototype에 할당한다.

  // Cat.prototype은 Cat의 인스턴스인 cat의 [[Prototype]] 링크가 가리키는 객체이기 때문에 
  
  // cat의 [[Prorotype]] -> Cat.prototype 참조
  // Cat.prototype의 [[Prototype]] -> Person.prototype 참조

  // 따라서 cat -> Cat.prototype -> Person.prototype의 [[Prototype]] 연쇄가 이루어진다.
  Cat.prototype = Object.cretate(Animal.prototype);

  // 위 코드 실행시 Cat.prorotype.constructor가 Animal이 되기 때문에, 생성자 함수를 올바르게 재할당 해주는 과정이 필요하다.
  Cat.prototype.constructor = Cat;
  ```