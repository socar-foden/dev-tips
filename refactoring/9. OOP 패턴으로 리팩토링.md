# 9. OOP 패턴으로 리팩토링

#### # 패턴

* 떠도는 모든 패턴을 암기할 필요는 없지만, `7가지 유용한 패턴`을 소개한다.

## 9.1 템플릿 메서드

#### # ** `객체의 if 분기`

* ** 특정 객체의 if 분기를 발견하면, `하위 객체로 분리할 수 있음`을 인지하고 있어야 한다.
  * 추출 전
    ```javascript
    class Person {
      constructor(binaryKnowledge) {
        this.binaryKnowledge = binaryKnowledge;
      };
      log(number) { // 하나의 Person 내에서 if 분기로 처리하고 있다.
        if (this.binaryKnowledge) {
          console.log(Number('0b' + number));
        } else {
          console.log(number);
        }
      };
    }

    const person_1 = new Person(true);
    const person_2 = new Person(false);

    person_1.log(10); // 2
    person_2.log(10); // 10
    ```
  * 추출 후(A)
    ```javascript
    class Person {

    }

    class BinaryPerson extends Person { // 하위 객체 1 - BinaryPerson
      log(number) {
        console.log(this.whatIsInBinary(number));
      };
      whatIsInBinary(number) {
        return Number('0b' + number);
      };
    }

    class NomalPerson extends Person { // 하위 객체 2 - NomalPerson
      log(number) {
        console.log(this.whatIs(number));
      };
      whatIs(number) {
        return number;
      };
    }

    const binaryKnowledge = new BinaryPerson();
    const normalPerson = new NomalPerson();

    binaryKnowledge.log(10); // 2
    normalPerson.log(10); // 10
    ```

#### # ** 같은 목적을 수행하는 `비슷한 두 알고리즘`

* ** `공통으로 사용하는 메서드의 call(호출)`(== `수행 알고리즘`)을 상위 객체에서 `'정의'`하고, `'세부 구현'`은 하위 객체에서 하는 것을 `템플릿 메서드 패턴`이라고 한다.
  * 추출 전 - 바로 위 `A 상태`
  * 추출 후(B)
    ```javascript
    class Person {
      log(number) { // 템플릿 메서드 log: 세부 구현의 전체적인 알고리즘을 정의해놓았다.
        console.log(this.whatIs(number));
      };
    }

    class BinaryPerson extends Person {
      whatIs(number) { // whatIs로 메서드명 통일
        return Number('0b' + number);
      };
    }

    class NomalPerson extends Person {
      whatIs(number) { // whatIs로 메서드명 통일
        return number;
      };
    }

    const binaryKnowledge = new BinaryPerson();
    const normalPerson = new NomalPerson();

    binaryKnowledge.log(10); // 2
    normalPerson.log(10); // 10
    ```

### 9.1.1 기능적 변형

#### # 함수형 패턴

* 동일한 기능을 함수형으로 바꾸면 아래와 같다.
  ```javascript
  function log(fun, number) {
    console.log(fun(number));
  }

  function whatIsBinary(number) {
    return Number('0b' + number);
  }

  function whatIs(number) {
    return number;
  }

  log(whatIsBinary, 10); // 2
  log(whatIs, 10); // 10
  ```

## 9.2 전략

#### # 하위 클래스를 제거

* `전략 패턴`: `템플릿 메서드 패턴`과는 반대로 `** 하위 클래스를 제거`하는 방법 중 하나이다.
* (`부모 객체에 전략 함수`를 붙인다.)
* 세부 구현에 따른 `하위 클래스들의 무분별한 확산`을 막기 위한 패턴이다.
* 추출 후(B) 상태에서
  * 만약 whatIs로 10배의 숫자를 반환하는 새로운 객체를 원한다면 아래와 같이 새로운 객체를 만들어야 한다.
    ```javascript
    class BinaryPerson extends Person {
      whatIs(number) {
        return number * 10;
      };
    }
    ```
  * 추가로 x2, +10... 등 다양한 객체가 생긴다면 그에 맞는 새로운 객체들을 생성해야 하므로, `새로운 종류의 객체가 무분별하게 증가`한다.
  * 이를 막기 위해 `whatIs를 '전략'으로 두고`, 하위 클래스를 없애 `유연한 방식으로 설계`가 가능하다.
    ```javascript
    class Person {
      constructor(whatIs) {
        this.whatIs = whatIs;
      };
      log(number) {
        console.log(this.whatIs(number));
      };
    }

    const binaryPerson = new Person(number => Number('0b' + number));
    const normalPerson = new Person(number => number);
    const times10Person = new Person(number => number * 10);
    const plus5Person = new Person(number => number + 5);

    binaryPerson.log(10); // 2
    normalPerson.log(10); // 10
    times10Person.log(10); // 100
    plus5Person.log(10); // 15
    ```
  * 위에서 전략(whatIs)은 `Person`에서 `static으로 관리`해도 되고, 따로 `모듈로 분리`해도 좋다.